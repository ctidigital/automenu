<?php
// $Id: automenu.module,v 1.1.2.1 2008/10/01 07:25:41 danielfs Exp $

/**
 * Implementation of hook_nodeapi().
 * Fill in menu section values if user left them empty AND there's a parent
 * menu item selected for this node type AND the node is published
 */
function automenu_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'submit':
      $parent_menu = _automenu_parent_menu($node);
      if ($parent_menu != 0) {
        if ((($node->menu['title'] == '') || ($node->menu['delete'])) && ($node->status == 1)) {
          $node->menu['title'] = $node->title;
          $node->menu['pid'] = $parent_menu;
          unset($node->menu['delete']);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 * Add the "Default Parent Menu" section to content type edit node.
 */
function automenu_form_alter($form_id, &$form) {
  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $form['workflow']['parentmenu'] = array(
      '#type' => 'select',
      '#title' => t('Default Parent Menu'),
      '#default_value' => variable_get('parentmenu_'. $form['#node_type']->type, 0),
      '#options' => _automenu_build_menu_opts()
    );
    $form['workflow']['menu_vocab'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary on which to base Submenu'),
      '#default_value' => variable_get("menu_vocab_{$form['#node_type']->type}", 0),
      '#options' => _automenu_vocab_opts($form['#node_type']),
    );
  }
}

/**
 * Build the menu list to show in the content type edit form.
 */
function _automenu_build_menu_opts($pid=0, $indent='') {

/**
 * Get a list of vocabularies we can base submenus off
 *
 * @param $type
 */
function _automenu_vocab_opts($type) {
  $sql = db_query("
    SELECT * FROM {vocabulary}
    INNER JOIN {vocabulary_node_types} ON vocabulary.vid = vocabulary_node_types.vid
    WHERE vocabulary_node_types.type = 'news'
  ");

  $opts = array(NULL => 'No Submenu');

  while($vocab = db_fetch_object($sql))
    $opts[$vocab->vid] = $vocab->name;

  return $opts;
}

  $t = menu_get_menu();
  $result = array($pid => $indent . $t['visible'][$pid]['title']);
  if (isset($t['visible'][$pid]['children'])) {
    foreach ($t['visible'][$pid]['children'] as $child) {
      $result += _automenu_build_menu_opts($child, '--'. $indent);
    }
  }
  return $result;
}

/**
 * Get the parent menu for a node, based on its category
 *
 * If there isn't a menu item for the node's category, this function will create one and return its mid.
 * This means that when nodes are deleted, we'll be leaving parent entries without categories lying around,
 * so we'll need to deal with that somewhere else.
 *
 * @param $node The node we want to insert into the menu
 * @returns The mid of the parent item
 */
function _automenu_parent_menu($node) {
  return variable_get('parentmenu_'. $node->type, 0);

}
